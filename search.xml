<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>关于博客的公式问题</title>
    <url>/2020/10/12/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%85%AC%E5%BC%8F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>简单更一下，最近关于插入排序和归并排序的博客还没写完，在写的过程中，难免要用到数学公式，如果要在hexo使用latex写数学公式的话，需要mathjax插件，为了这事，弄了两天，按照别人的教程一步步走，就是一直装不上，不知道是不是Mac Os系统的原因，不过Mac上有ipic这个神器，以后博客的公式部分，我会写好了截图，在用ipic把图片上传。</p>
<p>算法基础的后面一章，是为第三章打基础的，基本上全是数学，没啥算法，所以不用latex完全写不了，这也是我这几天这么急着装mathjax的原因，提前剧透一下，下一章比较硬核哦，这个博客的初衷就是把知识讲简单，但是还是避免不了使用数学公式，请做好心理准备哦～</p>
<p>由于公式渲染不出来，先看看两种效果吧</p>
<p>latex在hexo中直接写公式，渲染失败例</p>
<p>$ a_{1}^n $</p>
<p>在我的typora中这行代码是这样的</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gjml2gp9lrj302c02amx1.jpg" style="zoom:50%;">
<p>悲💩</p>
]]></content>
      <tags>
        <tag>一些废话🙃</tag>
      </tags>
  </entry>
  <entry>
    <title>关于这个博客的规划</title>
    <url>/2020/09/30/%E5%85%B3%E4%BA%8E%E8%BF%99%E4%B8%AA%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>这个博客创立的初衷是记录自己的学习和生活，后续每个星期会更新一篇长文，水品不一定高，但是我一定会竭尽全力把它写好，同时也会写一些生活趣事。如果每年的9月30号，打开博客，能看到自己一年的成长，也是件幸福的事。</p>
<h3 id="为什么要自己建博客，不直接将博客发在类似csdn的博客论坛上？"><a class="header-anchor" href="#为什么要自己建博客，不直接将博客发在类似csdn的博客论坛上？">¶</a>为什么要自己建博客，不直接将博客发在类似csdn的博客论坛上？</h3>
<p>有自己的博客，能给我一种在经营自己的家的感觉，如果把博客发在csdn，当然可以，但是总觉得少了点什么。这个博客是用hexo框架+next主题搭建github pages上的，博客是免费的，只有<a href="www.chinesesheep.com">www.chinesesheep.com</a> 这个域名花了我55元。虽然有点水，但是也能满足我的基本需求，如果搭建动态博客，需要的自己租服务器，而且也更难配置，先在我才大一刚毕业，等以后学习了一些前端知识，再考虑优化一下这个博客或者再搭建一个动态博客。</p>
<h3 id="一篇长文内容是什么？"><a class="header-anchor" href="#一篇长文内容是什么？">¶</a>一篇长文内容是什么？</h3>
<p>以后每个月会有一个总计划，规划一下这个月要写哪些内容，我对自己的要求是写别人写的少的，同时比较重要的知识，会尽量写的详细，有趣一些。</p>
<h3 id="这个博客的目标"><a class="header-anchor" href="#这个博客的目标">¶</a>这个博客的目标</h3>
<p>就像我之前说的那样，没什么远大的理想，就像写日记一样，用来记录自己的成长，<em>君子耻其言而过其行</em>，决定了什么事，赶紧开始做吧！</p>
]]></content>
  </entry>
  <entry>
    <title>算法基础——插入排序与归并排序</title>
    <url>/2020/10/05/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1>序</h1>
<p>这篇文章主要是依照《<a href="https://en.wikipedia.org/wiki/Introduction_to_Algorithms">算法导论</a>》这本书来写的，期间边看书边看<a href="https://www.bilibili.com/video/BV1Kx411f7bL">MIT的公开课</a> ，课是本书的作者之一讲的，这篇文章我会着重讲讲我听不明白的一些问题，并一一解决，文章篇幅较长，希望能耐心看完哦。</p>
<h1>简单的介绍</h1>
<p>回忆起第一次接触排序问题，是在大一的C语言课上，老师要我们通过两个for循环把一个数组中的元素从小到大排序，看着网上的技术博客勉勉强强写出来后，才知道这叫做冒泡排序，再后来，学了把两个有序的数组合并成一个大的有序数组，也就是这次归并排序的雏形。学习Java后，遇到排序问题，一般直接调用sort函数。仔细想想，其实我们排序数组的方法有那么多种，怎么写代码去实现的方法就更多了，那种好一些，那种坏一些，我从来没有仔细探究过，但在《算法导论》中，作者并没有强调源码怎么写，而是探究更深层次的问题，代码的性能优劣。</p>
<h1>什么是性能</h1>
<p>性能就是程序的运行速度，但是，<strong>一个程序的优劣，不仅仅要看性能，还要看许多其他的方面，比如安全性，可维护性。</strong></p>
<p>打个比方吧，假如你是一名学霸，每次考数学的时候，你都能提前半个小时把卷子写完，然后潇洒地提前交卷，但是，你总是跟全班第一差10分，你很苦恼，去问数学老师，老师说，你下次写慢点，不确定的题多检查一下，把字迹写工整一些。果然，下一次考试，你虽然没有像以往一样提前交卷，但你成了全班第一。</p>
<p>通过这个比方，我们可以知道，把卷子写的飞快，但是无法保证正确不行，字迹不工整不行。回到代码，一个程序，一秒钟就执行完了，但是结果是错的，另一个程序，一分钟才执行完，但是保证百分百正确。同样的例子还有很多，性能嘛，跟正确性，安全性等等没法比。**但是就像<a href="https://www.bilibili.com/video/BV1Kx411f7bL">MIT的公开课</a>里说的，性能就像货币，人要的不是更多的钱，而是钱能买来的东西。**尽管同样的程序，Java写的比C要慢很多，但是我们愿意用Java写程序，因为它能实现更多的功能。性能总是作为牺牲，去满足别的需求，这就是性能为什么处于底层的原因。</p>
<p>让我们通过一个都遇到过的例子来再说明一下吧。学习C语言时，都学多scanf函数吧，当我们兴奋的把写好的程序给同学运行时，同学往往不知道要输入啥，这时，我们需要用printf(“请输入一个XX数:”)，来提示同学要输入什么内容，加上这一段代码，程序就变得*“冗余”*了一些，多运行了一段代码，稍微慢了一些，但是，加强了我们代码的可读性。</p>
<p>说了这么多，相信大家都明白了性能的含义和作用，那么让我们来看看第一个算法——插入排序吧！</p>
<h1>插入排序</h1>
<h2 id="插入排序的伪代码"><a class="header-anchor" href="#插入排序的伪代码">¶</a>插入排序的伪代码</h2>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> j = <span class="number">2</span> to A.length   <span class="comment">//从第二个数遍历到数组末尾，j代表要比较的数</span></span><br><span class="line">	key = A[j]    <span class="comment">//记录A[j]的初始值</span></span><br><span class="line">	i = j - <span class="number">1</span>     <span class="comment">//i代表j的后一个数</span></span><br><span class="line">	<span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> A[i] &gt; key </span><br><span class="line">		A[i + <span class="number">1</span>] = A[i]</span><br><span class="line">		i = i - <span class="number">1</span></span><br><span class="line">	A[i + <span class="number">1</span>] = key     <span class="comment">//把A[j]的初始值赋给最后i前面的一个数</span></span><br></pre></td></tr></table></figure>
<p>先讲一下伪代码，主要有两个作用，<strong>用最简的语言表示算法，让无论学过什么语言的人都能最快看懂</strong>。最简不用多说，没分号，没大括号，循环用缩进表示，颇有python内味，我在原书代码的基础上加了一些注释，相信要看懂更加容易了。如果实在看不懂伪代码，可以看这篇<a href="https://www.runoob.com/w3cnote/insertion-sort.html">博客</a>，里面用各种语言写了插入排序。</p>
<p>我曾经做了一个作死的尝试，写了篇名叫*《不用代码讲插入排序》*的文章，后来写的冗长不说，意思也表达不清，索性作罢，用伪代码讲算法，虽然抽象，但是精确，简洁。</p>
<p>让我们用一串数组，来描述这个代码的执行过程</p>
<blockquote>
<p>{1, 2, 3, 5, 4}</p>
</blockquote>
<p>要把这个数组变成{1, 2, 3, 4, 5}会经历什么过程呢？</p>
<blockquote>
<p>1, 2, 3, 5, 5      第一步</p>
</blockquote>
<blockquote>
<p>1, 2, 3, 4, 5 	 第二步</p>
</blockquote>
<p>我们可以看到，其实，伪代码主要实现两种功能</p>
<h3 id="前提"><a class="header-anchor" href="#前提">¶</a>前提</h3>
<p>在上面的例子中，要排序4这个数，前提是4前面的数必须有序，因为排序是从2个数到3个数到4个数……排序3个数的基础是前面的2个数已经排好了，所以不要用类似{2，1，3，5，4}这样的不标准数组来测试代码哦，同时伪代码的数组并非从0开始，而是从1开始，A[5]的元素有A[1,2,3,4,5]而不是A[0,1,2,3,4]。</p>
<h3 id="移动"><a class="header-anchor" href="#移动">¶</a>移动</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">i</span> &gt; <span class="number">0</span> and A[<span class="built_in">i</span>] &gt; key</span><br><span class="line">	A[<span class="built_in">i</span> + <span class="number">1</span>] = A[<span class="built_in">i</span>]</span><br><span class="line">	<span class="built_in">i</span> = <span class="built_in">i</span> - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>先看while中后面的那一部分，A[i]  &gt;  key，配合后面的i = i - 1，从j的后面一个数开始，从后往前跟A[j]比大小</p>
<p>i &gt; 0是为了确定数组是否到头的，如果i自减到0，while循环就会停止</p>
<p>看前面的文章可以知道，key就是要插入的那个值，假设数组中的第五个数也就是A[5]的值是key，A[4]，A[3]，都比key大，A[2]比key小，如数组{1,2,4,5,3}，那么请拿出一张草稿纸，试着执行一下循环里面的代码。执行完循环之后，会得到这样一个数组{1,2,2,4,5}，i最后自减完的值是2，如果细心的话，会发现数组中元素的位置已经移动了，比3大的4和5，已经从原来的位置往后移动了一位，这时，只需要把第3个位置的2换成3，数组的排序就完成了。</p>
<h3 id="插入"><a class="header-anchor" href="#插入">¶</a>插入</h3>
<p>实现插入的代码只有一行</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">A[i + <span class="number">1</span>] = <span class="type">key</span> </span><br></pre></td></tr></table></figure>
<p>再用{1,2,4,5,3}举例子,我们进行完移动的操作后，得到的成果有{1，2，2，4，5}以及一个i值，i = 2</p>
<p>这里的i为插入操作进行引导，执行完A[i] &gt; key和i的自减后，我们可以知道，i前面的值都比key值小，A[i] = A[i + 1]，只需要把A[i + 1]替换为原来的A[j]值，即key，排序就完成了，看似是插入，如果执行过一遍程序后，就知道其实应该叫做替换。</p>
<h2 id="代码运算时间分析"><a class="header-anchor" href="#代码运算时间分析">¶</a>代码运算时间分析</h2>
<h3 id="该从哪个角度分析？"><a class="header-anchor" href="#该从哪个角度分析？">¶</a>该从哪个角度分析？</h3>
<p>运算时间受到的影响太多了，同样的代码，在超算和个人电脑上，运算时间肯定不同，个人电脑中，处理器型号，内存大小，也会导致执行的速度也不一样，但是，现在，我们仅从代码写法的角度来讨论运算时间的问题，而且是在最差的情况下的时间。</p>
<h3 id="为什么是最差的情况"><a class="header-anchor" href="#为什么是最差的情况">¶</a>为什么是最差的情况</h3>
<p>任何一个程序需要尽可能考虑差的情况，比如，一个排序数组的程序，在别人运行的时候，事先说明，<em>本程序排序完全颠倒的数组会很慢(类似{5，4，3，2，1})，其他时候都挺快的</em>，我觉得挺可笑的。一个程序设计的初衷就是要满足客户的各种合理需求的。记得在高考填志愿的时候，我不止一次抱怨填报志愿的网站做的差，好歹是全国人都会用的系统，为什么这么的“简朴”，后来经历过<a href="http://cet.neea.edu.cn">英语六级报名</a>，<a href="https://jlpt.neea.edu.cn">日语n2报名</a>后，发现其实做的网站都这样。后来仔细一想，其实全国的电脑中很大一部分是事业单位，高中机房中的老式电脑，不仅装的是XP系统，还装有360系，毒霸系的流氓软件，要是网页做的跟<a href="https://www.apple.com.cn">苹果官网</a>一样，一些电脑真不一定打得开。这些官方报名网站，设计时就考虑了兼容性的情况，同样，我们的代码也要考虑最差的情况。</p>
<h3 id="再看一次伪代码"><a class="header-anchor" href="#再看一次伪代码">¶</a>再看一次伪代码</h3>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> j = <span class="number">2</span> to A.length              <span class="regexp">//</span>a1</span><br><span class="line">	key = A[j]    				   <span class="regexp">//</span>a2</span><br><span class="line">	i = j - <span class="number">1</span>     				   <span class="regexp">//</span>a3</span><br><span class="line">	<span class="keyword">while</span> i &gt; <span class="number">0</span> and A[i] &gt; key     <span class="regexp">//</span>a4</span><br><span class="line">		A[i + <span class="number">1</span>] = A[i]            <span class="regexp">//</span>a5</span><br><span class="line">		i = i - <span class="number">1</span>                  <span class="regexp">//</span>a6</span><br><span class="line">	A[i + <span class="number">1</span>] = key                 <span class="regexp">//</span>a7     </span><br></pre></td></tr></table></figure>
<p>a1,a2……a7对应的每一行代码的执行时间</p>
<p>在输入后，我们规定运算总时间是T，T的值应该为<br>
T =n1a1 + n2a2 + ……n7a7</p>
<p>根据前面，算法要考虑最坏的情况，所以，我们默认排序的数组都是像{5,4,3,2,1}这种完全相反的数组，我们就可以得到n元素数组排序的最长时间。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">for</span> j = <span class="number">2</span> to A.length              //a<span class="number">1</span>		n</span><br><span class="line">	<span class="attribute">key</span> = A[j]    				   //a<span class="number">2</span>		n - <span class="number">1</span></span><br><span class="line">	<span class="attribute">i</span> = j - <span class="number">1</span>     				   //a<span class="number">3</span>		n - <span class="number">1</span></span><br><span class="line">	<span class="attribute">while</span> i &gt; <span class="number">0</span> and A[i] &gt; key     //a<span class="number">4</span>		<span class="number">2</span> + …… + n  </span><br><span class="line">		<span class="attribute">A</span>[i + <span class="number">1</span>] = A[i]            //a<span class="number">5</span>		<span class="number">1</span> + …… + n - <span class="number">1</span> </span><br><span class="line">		<span class="attribute">i</span> = i - <span class="number">1</span>                  //a<span class="number">6</span>		<span class="number">1</span> + …… + n - <span class="number">1</span></span><br><span class="line">	<span class="attribute">A</span>[i + <span class="number">1</span>] = key                 //a<span class="number">7</span>		n - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>后面的数代表执行次数，下面我来逐行讲解<br>
<strong>1</strong> 从2到n的遍历，看似应该执行n - 1次，但是循环的条件句最后还要判断一下，所以加一，如果这里不明白，可以看第4行代码的讲解<br>
<strong>2</strong> 每对应一个j值，都执行一次，共有n - 1个j值，执行你n - 1次<br>
<strong>3</strong> 与第2行一样<br>
<strong>4</strong> 由于是最差的情况，所以i每次都会自减到0，当i自减到0后，虽然循环内的代码不用执行，但是，是不是大于0还得比较一下，所以第4行代码是j为几就执行几次<br>
<strong>5</strong> 相比于第4行代码，每个j值都少一次i的值的判断，所以每轮执行次数都为j - 1，所以为从1到n - 1的和<br>
<strong>6</strong> 与第5行相同<br>
<strong>7</strong> 与第2行相同</p>
]]></content>
  </entry>
</search>
